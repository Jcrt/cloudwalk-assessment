// Package cw_logAnalyzer group all required artifacts to analyze the logs generated by log parser
// and aggregate all relevant information from game log structs
package cw_logAnalyzer

import (
	cw_logParser "cloudwalk-assessment/cw-logParser"
	"cloudwalk-assessment/quake3"
	"strconv"

	funk "github.com/thoas/go-funk"
)

// Defines the <world> code in the Kill logs
const worldKillerId int = 1022

// MatchInfo struct defines all information relative to the Game in analysis aspect
type MatchInfo struct {
	TotalKills int
	Players []string
	Kills map[string]int
}

// MODMatchInfo struct defines a map of all deaths occurred during the game and group it providing a counter of each Mean of Death
type MODMatchInfo struct {
	KillsByMeans map[string]int
}

// Func GetMatchesInfo build a map containing all matches and it's relevant information
// The parameter games receives an array of game log parser object
//
// Returns a map containing all matches
func GetMatchesInfo(matches []cw_logParser.Match) map[string]MatchInfo {
	matchesInfo := make(map[string]MatchInfo, 0)
	for index, match := range matches {
		
		currentMatch := MatchInfo {
			Players: getPlayerNames(match.Players),
			TotalKills: getTotalKills(match.Kills),
			Kills: getKillsByPlayer(match),
		}
		index := getMatchIdentifier(index)
		matchesInfo[index] = currentMatch
	}

	return matchesInfo;
}

// Func GetMODMatchesInfo build a map for each mean of death that occurred in logs, group it and count it
// The parameter games receives an array of game log parser object
//
// Returns a map containing all means of death grouped and counted
func GetMODMatchesInfo(games []cw_logParser.Match) map[string]MODMatchInfo {
	modMatchesInfo := make(map[string]MODMatchInfo)
	for index, match := range games {
		currentMODMatch := MODMatchInfo {
			KillsByMeans: getKillsByMean(match.Kills),
		}
		modMatchesInfo[getMatchIdentifier(index)] = currentMODMatch
	}	
	return modMatchesInfo
}

func getMatchIdentifier(matchNumber int) string {
	return "game_"+ strconv.Itoa(matchNumber + 1)
}

// Func getKillsByMean generates a map containing all means of death that occurred during a match
// The parameter kills receive an array of Kill and group it into a map with a counter
//
// Returns a map containing as key the name of mean of death and as value the amount of time that it occurs
func getKillsByMean(kills []cw_logParser.Kill) map[string]int {
	killsByMean := make(map[string]int)

	for _, kill := range kills {
		meanOfDeathName := quake3.MeanOfDeath(kill.MeanOfDeath).String()
		
		if entry, ok := killsByMean[meanOfDeathName]; ok {
			entry++
			killsByMean[meanOfDeathName] = entry
		} else {
			killsByMean[meanOfDeathName] = 1
		}
	}

	return killsByMean;
}

// Func getPlayerNames generates a string array containing all player names that have entered during a match
// The parameter gamePlayers receive a map of Player gathered from logs
//
// Returns a string array containing all player names at the end of the match
func getPlayerNames(matchPlayers map[int]cw_logParser.Player) []string {
		players := funk.Values(matchPlayers).([]cw_logParser.Player)
		playerNames := funk.Get(players, "Name").([]string)
		return playerNames;
}

// Func getTotalKills counts all kills occurred in a match
// The parameter gameKills receives a list of Kill and count it
//
// Returns an int with the total amount of kills occurred in the match
func getTotalKills(matchKills []cw_logParser.Kill) int{
	return len(matchKills)
}

// Func getKillsByPlayer groups all kills by player and count it
// If a player was killed by the <world>, it's scored is decreased by 1 every time that it happened
// The parameter game is the Game struct
//
// Returns a map where the key is the mean of kill and the value is an int as a counter of occurrences
func getKillsByPlayer(match cw_logParser.Match) map[string]int {
	killsByPlayer := make(map[string]int, 0)

	for _, player := range match.Players {
		killsByPlayer[player.Name] = 0
	}

	for _, kill := range match.Kills {
		playerName := match.Players[kill.KillerId].Name

		if value, ok := killsByPlayer[playerName]; ok{
			value++;
			killsByPlayer[playerName] = value
		} else if kill.KillerId == worldKillerId {
			killedPlayer := match.Players[kill.KilledId].Name
			killScore := killsByPlayer[killedPlayer]
			killScore--
			killsByPlayer[killedPlayer] = killScore
		}
	}

	return killsByPlayer
}
